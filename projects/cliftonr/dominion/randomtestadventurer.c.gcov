        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// Created by Robert Clifton
        -:    3://randomtestadventurer - random test for adventurer card function
        -:    4://
        -:    5://to make and test: make randomtestadventurer.out
        -:    6://
        -:    7://gcc dominion.c rngs.c randomtestadventurer.c -o randomtestadventurer
        -:    8:
        -:    9:#include "dominion.h"
        -:   10:#include "dominion_helpers.h"
        -:   11:#include <string.h>
        -:   12:#include <stdio.h>
        -:   13:#include <assert.h>
        -:   14:#include "rngs.h"
        -:   15:#include <stdlib.h>
        -:   16:#include <math.h>
        -:   17:#include <time.h>
        -:   18:
function main called 1 returned 100% blocks executed 92%
        -:   19:int main() {
        -:   20:
        1:   21:    int pass = 1;
        1:   22:    char testCard[] = "adventurer";
        -:   23:    struct gameState G, copyG;
        -:   24:    //int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse, sea_hag, tribute, smithy};
        -:   25:
        1:   26:    int x = 1000;
        -:   27:    int i, n, r, retVal;
        1:   28:    int handPos = 0;
        1:   29:    int choice1 = 0, choice2 = 0, choice3 = 0;
        1:   30:    int bonus = 0;
        -:   31:    int currentPlayer;
        1:   32:    int addedCards = 2;
        -:   33:    int money, copyMoney;
        -:   34:    int totalCards, copytotalCards;
        -:   35:
        -:   36:
        -:   37:    //initialize random
        1:   38:    srand(time(NULL));
        -:   39:
        -:   40:
        1:   41:    printf("\n->->->    - TESTING CARD: %s -    <-<-<-\n", testCard);
        -:   42:
        1:   43:    printf ("----  -RANDOM TESTS- ----\n");
        -:   44:
        -:   45:    //fill game struct with random numbers
     2002:   46:    for (i = 0; i < x; i++){
branch  0 taken 1000
branch  1 taken 1
 13152000:   47:        for (n = 0; n < sizeof(struct gameState)/ sizeof(int); n++) {
branch  0 taken 6575000
branch  1 taken 1000
  6575000:   48:            ((int*)&G)[n] = rand() % 128;
  6575000:   49:        }
        -:   50:
        -:   51:        //set important struct vars to valid random input
     1000:   52:        G.numPlayers = (rand() % 3)+2;
     1000:   53:        G.whoseTurn = rand() % G.numPlayers;
     1000:   54:        currentPlayer = whoseTurn(&G);
     1000:   55:        G.handCount[currentPlayer] = (rand() % (MAX_HAND/2))+1;
     1000:   56:        G.deckCount[currentPlayer] = (rand() % (MAX_DECK/2))+1;
     1000:   57:        G.discardCount[currentPlayer] = (rand() % (MAX_DECK/2))+1;
     1000:   58:        handPos = (rand() % G.handCount[currentPlayer]);
   256890:   59:        for (n = 0; n < G.handCount[currentPlayer]; n++) {
branch  0 taken 127445
branch  1 taken 1000
   127445:   60:            r = (rand() % 2);
   127445:   61:            if (r == 0) {
branch  0 taken 63515
branch  1 taken 63930
    63515:   62:                G.hand[currentPlayer][n] = copper;
    63515:   63:            } else {
    63930:   64:                G.hand[currentPlayer][n] = estate;
        -:   65:            }
   127445:   66:        }
   253938:   67:        for (n = 0; n < G.deckCount[currentPlayer]; n++) {
branch  0 taken 125969
branch  1 taken 1000
   125969:   68:            r = (rand() % 2);
   125969:   69:            if (r == 0) {
branch  0 taken 63235
branch  1 taken 62734
    63235:   70:                G.deck[currentPlayer][n] = copper;
    63235:   71:            } else {
    62734:   72:                G.deck[currentPlayer][n] = estate;
        -:   73:            }
   125969:   74:        }
        -:   75:
        -:   76:        //copy struct for testing and compare
     1000:   77:        memcpy(&copyG, &G, sizeof(struct gameState));
        -:   78:
        -:   79:        //test return value
     1000:   80:        retVal = cardEffect(adventurer, choice1, choice2, choice3, &copyG, handPos, &bonus);
     1000:   81:        if (retVal != 0) {
branch  0 taken 0
branch  1 taken 1000
    #####:   82:            printf("Return Fail");
    #####:   83:            pass = 0;
    #####:   84:        };
        -:   85:
        -:   86:        //test hand count
     1000:   87:        if (copyG.handCount[currentPlayer] != G.handCount[currentPlayer]+addedCards){
branch  0 taken 3
branch  1 taken 997
        3:   88:            pass = 0;
        -:   89:			//printf("NP:%d, WT:%d, HC:%d, DC:%d, %d, HP:%d\n", G.numPlayers, G.whoseTurn, G.handCount[currentPlayer], G.deckCount[currentPlayer], G.discardCount[currentPlayer], handPos);
        -:   90:			//printf("NP:%d, WT:%d, HC:%d, DC:%d, %d, HP:%d\n", copyG.numPlayers, copyG.whoseTurn, copyG.handCount[currentPlayer], copyG.deckCount[currentPlayer], copyG.discardCount[currentPlayer], handPos);
        3:   91:            printf("Hand Count: %d, Expected: %d \n\n", copyG.handCount[currentPlayer], G.handCount[currentPlayer]+addedCards);
        3:   92:        }
        -:   93:
        -:   94:        //test deck and discard count
     1000:   95:        totalCards = G.deckCount[currentPlayer] + G.discardCount[currentPlayer];
     1000:   96:        copytotalCards = copyG.deckCount[currentPlayer] + copyG.discardCount[currentPlayer];
     1000:   97:        if (copytotalCards != totalCards - addedCards) {
branch  0 taken 3
branch  1 taken 997
        3:   98:            pass = 0;
        3:   99:            printf("Total Cards: %d, Expected: %d \n\n", copytotalCards, totalCards-addedCards);
        3:  100:        };
        -:  101:
        -:  102:        //test treasure count
     1000:  103:        money = 0;
     1000:  104:        n = 0;
   256890:  105:        while (n < numHandCards(&G)) {
branch  0 taken 127445
branch  1 taken 1000
   127445:  106:            if (handCard(n, &G) == copper) {
branch  0 taken 63515
branch  1 taken 63930
    63515:  107:                money++;
   127445:  108:            } else if (handCard(n, &G) == silver) {
branch  0 taken 0
branch  1 taken 63930
    #####:  109:                money += 2;
    63930:  110:            } else if (handCard(n, &G) == gold) {
branch  0 taken 0
branch  1 taken 63930
    #####:  111:                money += 3;
    #####:  112:            }
   127445:  113:            n++;
        -:  114:        }
        -:  115:
     1000:  116:        copyMoney = 0;
     1000:  117:        n = 0;
   260882:  118:        while (n < numHandCards(&copyG)) {
branch  0 taken 129441
branch  1 taken 1000
   129441:  119:            if (handCard(n, &copyG) == copper) {
branch  0 taken 65508
branch  1 taken 63933
    65508:  120:                copyMoney++;
   129441:  121:            } else if (handCard(n, &copyG) == silver) {
branch  0 taken 2
branch  1 taken 63931
        2:  122:                copyMoney += 2;
    63933:  123:            } else if (handCard(n, &copyG) == gold) {
branch  0 taken 1
branch  1 taken 63930
        1:  124:                copyMoney += 3;
        1:  125:            }
   129441:  126:            n++;
        -:  127:        };
     1000:  128:        if (copyMoney < money+2) {
branch  0 taken 3
branch  1 taken 997
        3:  129:            pass = 0;
        3:  130:            printf("Money Count: %d, Expected Money Count: >= %d \n\n", copyMoney, money+2);
        3:  131:        }
        -:  132:        
        -:  133:
     1000:  134:    }
        -:  135:
        -:  136:
        -:  137:    //Final bool check to see if testing passed or failed,  prints result to standard out
        1:  138:    if (pass) {
branch  0 taken 0
branch  1 taken 1
    #####:  139:        printf("->->  - TEST SUCCESSFULLY COMPLETED -  <-<-\n");
    #####:  140:    } else{
        1:  141:        printf("->->  - TEST FAILED -  <-<-\n");
        -:  142:    }
        -:  143:
        1:  144:    return 0;
        -:  145:};
